<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python | Yuma Uchiumi</title>
    <link>https://yumaloop.github.io/tag/python/</link>
      <atom:link href="https://yumaloop.github.io/tag/python/index.xml" rel="self" type="application/rss+xml" />
    <description>Python</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© Yuma Uchiumi 2018-2022</copyright><lastBuildDate>Sun, 20 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://yumaloop.github.io/media/static/media/icon.png</url>
      <title>Python</title>
      <link>https://yumaloop.github.io/tag/python/</link>
    </image>
    
    <item>
      <title>StackOverflow - 2020 Developer Survey</title>
      <link>https://yumaloop.github.io/post/2020-12-20-stackoverflow-developer-survey-2020/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://yumaloop.github.io/post/2020-12-20-stackoverflow-developer-survey-2020/</guid>
      <description>&lt;p&gt;StackOverflow published its &lt;strong&gt;Developer Survey 2020&lt;/strong&gt;. Click &lt;a href=&#34;https://insights.stackoverflow.com/survey/2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; for details.&lt;/p&gt;
&lt;p&gt;In 2020,
&lt;strong&gt;Python&lt;/strong&gt;, &lt;strong&gt;Go&lt;/strong&gt;, &lt;strong&gt;TypeScript&lt;/strong&gt;, &lt;strong&gt;Rust&lt;/strong&gt; are the programming language most loved by developers in the world.
It means that these languages are in vogue and new learners are on the rise.
While &lt;strong&gt;JavaScript&lt;/strong&gt; swallows everything, &lt;strong&gt;Perl&lt;/strong&gt;, &lt;strong&gt;PHP&lt;/strong&gt;, and &lt;strong&gt;Ruby&lt;/strong&gt; seem to be still in high demand.&lt;/p&gt;
&lt;p&gt;Frameworks packaging frontends, backends and database into one, such as Rails, are already not preferred.
Today, dividing frontends with &lt;strong&gt;JavaScript&lt;/strong&gt; (&lt;strong&gt;Node.js&lt;/strong&gt;, &lt;strong&gt;Vue.js&lt;/strong&gt;, &lt;strong&gt;React.js&lt;/strong&gt;)
and backends/database with scalable cloud services (&lt;strong&gt;AWS&lt;/strong&gt;, &lt;strong&gt;GCP&lt;/strong&gt;)
is major approach for adaptive web applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt; and &lt;strong&gt;Java&lt;/strong&gt; have always been very popular
and in demand as general languages that can be used for many purposes.
In the future, it will be interesting to see if &lt;strong&gt;Go&lt;/strong&gt; and &lt;strong&gt;Rust&lt;/strong&gt; can take their place.&lt;/p&gt;
&lt;p&gt;Finally, I would like to introduce the cluster map of major development technologies found by the StackOverflow Developer Survey 2020.
With the penetration of new technologies such as &lt;strong&gt;mobile&lt;/strong&gt;, &lt;strong&gt;container&lt;/strong&gt; and &lt;strong&gt;cloud computing&lt;/strong&gt;,
it will be more difficult to become a full-stack engineer in the near future.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Assembly, C, C++&lt;/li&gt;
&lt;li&gt;Raspberry Pi, Arduino&lt;/li&gt;
&lt;li&gt;Unity, UnrealEngine&lt;/li&gt;
&lt;li&gt;Hadoop, Scala, Apache Spark&lt;/li&gt;
&lt;li&gt;Python, Pandas, Torch/PyTorch&lt;/li&gt;
&lt;li&gt;Linux, Docker, Kubernetes, Bash/Shell&lt;/li&gt;
&lt;li&gt;AWS, Redis, Ansible, DynamoDB, PostgreSQL&lt;/li&gt;
&lt;li&gt;JavaScript, Node.js, React.js, Angular, TypeScript, MongoDB,&lt;/li&gt;
&lt;li&gt;PHP, MySQL, jQuery, WordPress&lt;/li&gt;
&lt;li&gt;Java, Swift, Android, iOS, Kotlin, SQLite, Firebase&lt;/li&gt;
&lt;li&gt;C#, .NET, Windows, Azure&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;./so_ds_2020_cluster.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Maximize the cell size of Jupyter notebook</title>
      <link>https://yumaloop.github.io/post/2020-11-29-maximize-jupyter-notebook-cell-height/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://yumaloop.github.io/post/2020-11-29-maximize-jupyter-notebook-cell-height/</guid>
      <description>&lt;h3 id=&#34;tldr&#34;&gt;TL;DR&lt;/h3&gt;
&lt;p&gt;Put the following magic command (cell magic) in a cell and execute it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;%%javascript
IPython.OutputArea.auto_scroll_threshold = 9999;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: This is not &lt;code&gt;line magic&lt;/code&gt; like &lt;code&gt;% matplotlib inline&lt;/code&gt; and some errors will occur unless the executed cell is independent.
See &lt;a href=&#34;https://ipython.readthedocs.io/en/stable/interactive/magics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPython Official Documentation&lt;/a&gt; for details.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; - All available &lt;em&gt;line magic&lt;/em&gt; commands - &lt;a href=&#34;https://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;check here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%%&lt;/code&gt; - All available &lt;em&gt;cell magic&lt;/em&gt; commands - &lt;a href=&#34;https://ipython.readthedocs.io/en/stable/interactive/magics.html#cell-magics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;check here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cf&#34;&gt;Cf.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ipython.readthedocs.io/en/stable/interactive/tutorial.html#magic-functions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Magic functions - IPython公式ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipython/ipython/issues/2172#issuecomment-53708976&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;comment:53708976 issue:2172 ipython github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qastack.jp/programming/18770504/resize-ipython-notebook-output-window&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ipythonノートブックの出力ウィンドウのサイズを変更する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/daifuku_mochi2/items/30258e58750ff8e85d37&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter notebookで列をすべて表示したい - Qitta&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Basic Portfolio Optimization with Python: Markowitz&#39;s Mean-Variance Model</title>
      <link>https://yumaloop.github.io/post/2020-11-12-portfolio-optimization-by-python/</link>
      <pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://yumaloop.github.io/post/2020-11-12-portfolio-optimization-by-python/</guid>
      <description>&lt;p&gt;Pythonでbacktestする際のTipsをまとめたものです．面倒な前処理をさくっと終わらせてモデル作りに専念しましょう！という主旨です．記事では紹介していませんが，&lt;code&gt;pandas-datareader&lt;/code&gt;でマクロデータもだいたい取れるので，複数因子モデルなど，さまざまなポートフォリオ選択モデルを試すことができます．&lt;/p&gt;
&lt;font color=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;Overview:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PythonでBacktestする環境を整える．&lt;/li&gt;
&lt;li&gt;東証TOPIX構成銘柄から対象資産を選び最小分散ポートフォリオを組む．&lt;/li&gt;
&lt;/ol&gt;
&lt;/font&gt;
&lt;br&gt;
&lt;h2 id=&#34;1-株価データの取得&#34;&gt;1. 株価データの取得&lt;/h2&gt;
&lt;br&gt;
&lt;p&gt;まず，&lt;code&gt;pandas-datareader&lt;/code&gt;を環境にインストールします．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pandas-datareader&lt;/code&gt;は，株価などの市場データをWeb API経由でダウンロードできる（pandas.Dataframe friendlyで）便利なPythonパッケージです．IEX, World Bank, OECD, &lt;a href=&#34;https://finance.yahoo.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Yahoo! Finance&lt;/a&gt;，&lt;a href=&#34;https://fred.stlouisfed.org/docs/api/fred/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FRED&lt;/a&gt;，&lt;a href=&#34;https://stooq.com/q/?s=usdkrw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stooq&lt;/a&gt;などのAPIを内部で叩き、pythonコード上に取得したデータを読み込みことができます．詳しい使い方は&lt;a href=&#34;https://pandas-datareader.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式ドキュメント&lt;/a&gt;を参照してください．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install pandas-datareader (latest version)
pip install git+https://github.com/pydata/pandas-datareader.git
# Or install pandas-datareader (stable version)
pip install pandas-datareader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今回は，東京証券取引所（東証）に上場している株式銘柄を対象商品とします．
Web上で公開されているデータは圧倒的に米国市場のものが多いですが，ポーランドの最強サイト&lt;a href=&#34;https://stooq.com/q/?s=usdkrw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stooq.com&lt;/a&gt;は東京証券取引所の過去データを公開しています．&lt;code&gt;pandas-datareader&lt;/code&gt;を使ってstooqから個別銘柄のデータを取得しましょう．&lt;/p&gt;
&lt;p&gt;基本的には，&lt;code&gt;pandas_datareader.stooq.StooqDailyReader()&lt;/code&gt;を実行すればOKです．引数には，各市場に登録してある証券コード(or ティッカーシンボル)と、データ公開元のサイト(Yahoo!, Stooq, &amp;hellip;)を指定します．&lt;/p&gt;
&lt;p&gt;東京証券取引所で取り扱いされている株式銘柄には，4桁の証券コードが割り当てられているので、今回はこれを使います．（例：&lt;a href=&#34;https://stocks.finance.yahoo.co.jp/stocks/detail/?code=7203&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;トヨタ自動車&lt;/a&gt;の株式は、東証では証券コードが&lt;strong&gt;7203&lt;/strong&gt;である銘柄として，NYSEではティッカーシンボルが&lt;strong&gt;TM&lt;/strong&gt;である銘柄として取引されています．）&lt;/p&gt;
&lt;p&gt;試しに，トヨタ自動車(東証:7203)の株価データを取得してプロットしてみましょう，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import datetime
import pandas_datareader

start = datetime.datetime(2015, 1, 1)
end = datetime.datetime(2020, 11, 30)
stockcode = &amp;quot;7203.jp&amp;quot; # Toyota Motor Corporation (TM)

df = pandas_datareader.stooq.StooqDailyReader(stockcode, start, end).read()
df = df.sort_values(by=&#39;Date&#39;,ascending=True)
display(df) # Show dataframe
-----
            Open	High	Low	    Close	Volume
Date					
2015-01-05	6756.50	6765.42	6623.43	6704.69	10653925
2015-01-06	6539.48	6601.09	6519.83	6519.83	13870266
2015-01-07	6480.52	6685.05	6479.64	6615.40	12837377
2015-01-08	6698.46	6748.46	6693.98	6746.69	11257646
2015-01-09	6814.56	6846.70	6752.92	6795.80	11672928
...	...	...	...	...	...
2020-11-04	7024.00	7054.00	6976.00	6976.00	6278100
2020-11-05	6955.00	7032.00	6923.00	6984.00	5643400
2020-11-06	7070.00	7152.00	7015.00	7019.00	11092900
2020-11-09	7159.00	7242.00	7119.00	7173.00	7838600
2020-11-10	7320.00	7360.00	7212.00	7267.00	8825700
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日別の株価推移データがpandas.Dataframeとして取得できました！
いま作成した&lt;code&gt;df&lt;/code&gt;の中身をプロットしてみます．（基本的に終値をつかいます）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Plot timeseries (2015/1/1 - 2020/11/30)
plt.figure(figsize=(12,8))
plt.plot(df.index, df[&amp;quot;Close&amp;quot;].values)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下図のように，終値(Close)の推移が簡単にプロットできました．
&lt;img src=&#34;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/295228/ef4c8a3e-7e1b-4a6e-d1e2-40f12c91691c.png&#34; alt=&#34;hoge.png&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;2-対象資産のパネルデータを作る&#34;&gt;2. 対象資産のパネルデータを作る&lt;/h2&gt;
&lt;br&gt;
&lt;p&gt;ポートフォリオ最適化問題を解くための準備として，複数の資産(株式銘柄)に対するパネルデータを作り，pandas.Dataframeオブジェクトとして整理します．&lt;/p&gt;
&lt;p&gt;今回は&lt;a href=&#34;https://www.jpx.co.jp/markets/indices/topix/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOPIX 500&lt;/a&gt;に掲載されている銘柄から5つ選び，投資対象資産とします．また，前処理として「終値」を「終値ベースの収益率」へ変換しています．この部分のコードは状況に合わせて変えてください．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import datetime
import numpy as np
import pandas as pd
import pandas_datareader.data as web
import pandas_datareader.stooq as stooq


def get_stockvalues_tokyo(stockcode, start, end, use_ratio=False):
    &amp;quot;&amp;quot;&amp;quot;
    stockcode: market code of each target stock (ex. &amp;quot;NNNN&amp;quot;) defined by the Tokyo stock market.
    start, end: datetime object
    &amp;quot;&amp;quot;&amp;quot;
    # Get index data from https://stooq.com/
    df = stooq.StooqDailyReader(f&amp;quot;{stockcode}.jp&amp;quot;, start, end).read()
    df = df.sort_values(by=&#39;Date&#39;,ascending=True)
    
    if use_ratio:
        df = df.apply(lambda x: (x - x[0]) / x[0] )
    return df

def get_paneldata_tokyo(stockcodes, start, end, use_ratio=False):
    # Use &amp;quot;Close&amp;quot; value only 
    dfs = []
    for sc in stockcodes:
        df = get_stockvalues_tokyo(sc, start, end, use_ratio)[[&#39;Close&#39;]]
        df = df.rename(columns={&#39;Close&#39;: sc})
        dfs.append(df)
    df_concat = pd.concat(dfs, axis=1)
    return df_concat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;get_paneldata_tokyo()&lt;/code&gt;を使ってパネルデータを作成します．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;start = datetime.datetime(2015, 1, 1)
end = datetime.datetime(2020, 11, 30)
stockcodes=[&amp;quot;1301&amp;quot;, &amp;quot;1762&amp;quot;, &amp;quot;1820&amp;quot;, &amp;quot;1967&amp;quot;, &amp;quot;2127&amp;quot;]

df = get_paneldata_tokyo(stockcodes, start, end, use_ratio=True)
display(df) # return ratio daily
-----
            1301	    1762    	1820    	1967	    2127
Date					
2015-01-05	0.000000	0.000000	0.000000	0.000000	0.000000
2015-01-06	-0.010929	-0.018385	-0.033937	-0.002265	-0.038448
2015-01-07	-0.014564	-0.020433	-0.059863	-0.013823	-0.059680
2015-01-08	-0.007302	-0.016338	-0.057883	-0.013823	-0.039787
2015-01-09	0.000000	-0.004490	-0.031938	-0.025407	-0.043770
...	...	...	...	...	...
2020-10-29	0.096138	-0.032923	-0.030777	0.858573	5.682321
2020-10-30	0.093336	-0.039657	-0.041199	0.832831	5.704266
2020-11-02	0.107748	-0.026188	-0.032198	0.845702	5.418978
2020-11-04	0.099341	-0.024392	-0.020829	0.858573	5.704266
2020-11-05	0.069315	-0.014964	-0.042147	0.904909	6.055390
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで，評価対象となる各資産のパネルデータを取得できました．&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;3-マーコビッツの平均分散モデルとその解法&#34;&gt;3. マーコビッツの平均分散モデルとその解法&lt;/h2&gt;
&lt;br&gt;
&lt;p&gt;投資対象となる複数の資産に対して，適当な投資比率をそれぞれ決定することを&lt;strong&gt;ポートフォリオ最適化&lt;/strong&gt;といいます．今回は，最も基本的なポートフォリオ最適化の問題設定として，Markowitzが提唱した&lt;strong&gt;平均分散モデル&lt;/strong&gt;(Mean-Variance Model)を採用します．&lt;/p&gt;
&lt;h3 id=&#34;31-markowitzの平均分散モデル&#34;&gt;3.1. Markowitzの平均分散モデル&lt;/h3&gt;
&lt;p&gt;Markowitzの平均分散モデルでは，「ポートフォリオの期待収益率(Expected return)が一定値以上となる」という制約条件の下で，「ポートフォリオの分散を最小化する」最適化問題を考えます．&lt;/p&gt;
&lt;p&gt;一般に，$n$コの資産で構成されるポートフォリオの場合，ポートフォリオの分散は$n$コの資産間の共分散行列の二次形式となるので，この最適化問題は二次計画問題(Quadratic Programming, QP)のクラスとなり，次のように定式化されます．&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\underset{\bf x}{\rm minimize} ~~~ &amp;amp;{\bf x}^T \Sigma {\bf x} \\&lt;br&gt;
{\rm subject~to} ~~~ &amp;amp;{\bf r}^T {\bf x} = \sum_{i=1}^{n} r_i x_i \geq r_e \\&lt;br&gt;
&amp;amp;{|| {\bf x} ||}_{1} = \sum_{i=1}^{n} x_i = 1 \\&lt;br&gt;
&amp;amp;x_i \geq 0 ~~ (i = 1, \cdots, n)
\end{align}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\Sigma \in \mathbb{R}^{n \times n}$ ー $n$コの資産の共分散行列&lt;/li&gt;
&lt;li&gt;${\bf x} \in \mathbb{R}^{n}$ ー $n$コの資産の投資比率ベクトル&lt;/li&gt;
&lt;li&gt;$\bar{\bf r} \in \mathbb{R}^{n}$ ー $n$コの資産の期待収益率ベクトル&lt;/li&gt;
&lt;li&gt;$x_i \in \mathbb{R}$ ー 資産$i$の投資比率&lt;/li&gt;
&lt;li&gt;$\bar{r}_i \in \mathbb{R}$ ー 資産$i$の期待収益率&lt;/li&gt;
&lt;li&gt;$r_e \in \mathbb{R}$ ー 投資家の要求期待収益率&lt;/li&gt;
&lt;li&gt;$\bar{r}_p \in \mathbb{R}$ ー ポートフォリオの収益率の期待値&lt;/li&gt;
&lt;li&gt;$\sigma_p \in \mathbb{R}$ ー ポートフォリオの収益率の標準偏差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1つ目の制約式は，ポートフォリオの期待収益率が一定値($=r_e$)以上となることを要請しています．2つ目，3つ目の制約式はポートフォリオの定義からくる自明なものです．資産の空売りを許す場合，3つ目の制約式を除くこともあります．&lt;/p&gt;
&lt;h3 id=&#34;32-cvxoptの使い方&#34;&gt;3.2. CVXOPTの使い方&lt;/h3&gt;
&lt;p&gt;Pythonの凸最適化向けパッケージ&lt;a href=&#34;https://cvxopt.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CVXOPT&lt;/a&gt;を使って，この二次計画問題(QP)を解きます．
CVXOPTで二次計画問題を扱う場合は，解きたい最適化問題を以下の一般化されたフォーマットに整理して，&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\underset{\bf x}{\rm minimize} ~~~ &amp;amp;\frac{1}{2} {\bf x}^{T} P {\bf x} + {\bf q}^{T} {\bf x} \\&lt;br&gt;
{\rm subject~to} ~~~ &amp;amp; G {\bf x} \leq {\bf h} \\&lt;br&gt;
&amp;amp;A {\bf x} = {\bf b}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;パラメータ&lt;code&gt;P&lt;/code&gt;,&lt;code&gt;q&lt;/code&gt;,&lt;code&gt;G&lt;/code&gt;,&lt;code&gt;h&lt;/code&gt;,&lt;code&gt;A&lt;/code&gt;を計算し，&lt;code&gt;cvxopt.solvers.qp()&lt;/code&gt;関数を実行することで最適解と最適値を求めます．Markowitzの平均・分散モデルの場合は，&lt;/p&gt;
&lt;p&gt;$$
P = 2 \cdot \Sigma, ~~~
q = {\bf 0}_n, ~~~
G = -1 \cdot
\begin{pmatrix}
\bar{r}_1 &amp;amp; \cdots &amp;amp; \bar{r}_n \\&lt;br&gt;
1 &amp;amp; \cdots &amp;amp; 0 \\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;
0 &amp;amp; \cdots &amp;amp; 1
\end{pmatrix}, ~~~
h = -1 \cdot
\left(
\begin{array}{c}
r_e \\&lt;br&gt;
0 \\&lt;br&gt;
\vdots \\&lt;br&gt;
0
\end{array}
\right), ~~~
A = {\bf 1}_n^{\mathrm{T}}, ~~~
b = 1
$$&lt;/p&gt;
&lt;p&gt;となります．&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cvxopt.org/userguide/coneprog.html#quadratic-programming&#34;&gt;https://cvxopt.org/userguide/coneprog.html#quadratic-programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ryoshi81/items/8b0c6add3e367f94c828&#34;&gt;https://qiita.com/ryoshi81/items/8b0c6add3e367f94c828&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-pythonで計算&#34;&gt;3.3. Pythonで計算&lt;/h3&gt;
&lt;p&gt;対象資産のパネルデータ&lt;code&gt;df&lt;/code&gt;から，必要な統計量を計算します．&lt;/p&gt;
&lt;p&gt;ポートフォリオ内の資産間の共分散行列 $\Sigma$：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.cov() # Covariance matrix
-----
        1301	    1762        1820	    1967	    2127
1301	0.024211	0.015340	0.018243	0.037772	0.081221
1762	0.015340	0.014867	0.015562	0.023735	0.038868
1820	0.018243	0.015562	0.025023	0.029918	0.040811
1967	0.037772	0.023735	0.029918	0.109754	0.312827
2127	0.081221	0.038868	0.040811	0.312827	1.703412
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ポートフォリオ内の各資産の期待収益率 ${\bf r}$：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.mean().values # Expected returns
-----
array([0.12547322, 0.10879767, 0.07469455, 0.44782516, 1.75209493])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CVXOPTを使って最適化問題を解く．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cvxopt

def cvxopt_qp_solver(r, r_e, cov):
    # CVXOPT QP Solver for Markowitz&#39; Mean-Variance Model
    # See https://cvxopt.org/userguide/coneprog.html#quadratic-programming
    # See https://cdn.hackaday.io/files/277521187341568/art-mpt.pdf
    n = len(r)
    r = cvxopt.matrix(r)
    
    P = cvxopt.matrix(2.0 * np.array(cov))
    q = cvxopt.matrix(np.zeros((n, 1)))
    G = cvxopt.matrix(np.concatenate((-np.transpose(r), -np.identity(n)), 0))
    h = cvxopt.matrix(np.concatenate((-np.ones((1,1)) * r_e, np.zeros((n,1))), 0))
    A = cvxopt.matrix(1.0, (1, n))
    b = cvxopt.matrix(1.0)    
    sol = cvxopt.solvers.qp(P, q, G, h, A, b)
    return sol
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;r = df.mean().values # Expected returns
r_e = 0.005 * # Lower bound for portfolio&#39;s return
cov = df.cov() # Covariance matrix

# Solve QP and derive optimal portfolio
sol = cvxopt_qp_solver(r, r_e, cov)
x_opt = np.array(sol[&#39;x&#39;])
print(x_opt)
print(&amp;quot;Variance (x_opt) :&amp;quot;, sol[&amp;quot;primal objective&amp;quot;])

-----

 pcost       dcost       gap    pres   dres
 0:  4.3680e-03 -8.6883e-02  5e+00  2e+00  2e+00
 1:  9.1180e-02 -2.2275e-01  5e-01  1e-01  1e-01
 2:  2.1337e-02 -6.0274e-02  8e-02  2e-16  1e-16
 3:  1.0483e-02 -1.7810e-03  1e-02  1e-16  3e-17
 4:  4.9857e-03  1.5180e-03  3e-03  2e-16  8e-18
 5:  4.0217e-03  3.6059e-03  4e-04  3e-17  1e-17
 6:  3.7560e-03  3.7107e-03  5e-05  3e-17  1e-18
 7:  3.7187e-03  3.7168e-03  2e-06  1e-17  4e-18
 8:  3.7169e-03  3.7168e-03  2e-08  1e-16  6e-18
Optimal solution found.
[ 5.56e-05]
[ 1.00e+00]
[ 1.76e-05]
[ 3.84e-07]
[ 2.63e-07]

Variance (x_opt):  0.003716866155475511 # 最適ポートフォリオの分散
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最適解（各資産への最適な投資比率）と，最適値（最適な投資比率を適用した場合のポートフォリオの分散）が求められました．なお，今回使った平均分散モデルによる最適解はポートフォリオのリスク(分散)に対する最適性を重視しているので，「最小分散ポートフォリオ」と呼ばれます．&lt;/p&gt;
&lt;p&gt;なお，収益率に対する評価指標には，無リスク資産の収益率(インフレ率)を加味したシャープレシオを用いるケースが多いです．backtestの方法についてはいくつか流儀があるので，専門書や論文を参照してください．&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;4-実装例&#34;&gt;4. 実装例&lt;/h2&gt;
&lt;br&gt;
&lt;p&gt;上のコードをまとめて，自作のバックテスト用Pythonクラス&lt;code&gt;MarkowitzMinVarianceModel()&lt;/code&gt;を作りました．
以下は参考例です．&lt;/p&gt;
&lt;h3 id=&#34;41-バックテスト用のpythonクラス&#34;&gt;4.1. バックテスト用のPythonクラス&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cvxopt
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class MarkowitzMinVarianceModel():
    &amp;quot;&amp;quot;&amp;quot;
    Args:
    =====
    - df: pandas.dataframe
        panel data for target assets for the portfolio. 
            its index must be `numpy.datetime64` type.
            its columns must be time-series data of target assets.
    - window_size: int
        the size of time-window which is used when deriving (or updating) the portfolio.
    - rebalance_freq: int
        rebalance frequency of the portfolio.
    - r_e: float
        min of the return ratio (= capital gain / investment).
    - r_f: float
        rate of returns of the risk-free asset.
    &amp;quot;&amp;quot;&amp;quot;
    def __init__(self, df, window_size, rebalance_freq, r_e=None, r_f=None):
        self.df = self._reset_index(df)
        self.df_chg = self.df.pct_change()
        self.df_chg[:1] = 0.0 # set 0.0 to the first record
        self.df_bt = None
        self.df_bt_r = None
        self.df_bt_x = None
        self.window_size = window_size
        self.rebalance_freq = rebalance_freq
        self.jgb_int = 0.0001 # 0.01% per year (Japanese Government Bond)
        self.r_f = r_f if r_f is not None else self.jgb_int * (1/12) # adjust monthly
        self.r_e = r_e if r_e is not None else r_f
        
    def _reset_index(self, df):
        df = df.copy()
        df[&#39;date&#39;] = pd.to_datetime(df.index)
        df = df.set_index(&#39;date&#39;)
        return df
    
    def get_dfbt_r(self):
        return self.df_bt_r
    
    def get_dfbt_x(self):
        return self.df_bt_x
        
    def backtest(self):
        date_init = self.df.index.values[self.window_size]
        df_bt = pd.DataFrame([[0.0, np.nan]], index=[date_init], columns=[&#39;ror&#39;, &#39;std&#39;])
        df_bt_r = pd.DataFrame(columns=list(self.df.columns.values))
        df_bt_x = pd.DataFrame(columns=list(self.df.columns.values))
        for idx, date in enumerate(self.df.index.values):
            if idx &amp;gt;= self.window_size + self.rebalance_freq:
                if (idx - self.window_size) % self.rebalance_freq == 0:
                    # df_chg_train
                    st = idx - self.rebalance_freq - self.window_size
                    ed = idx - self.rebalance_freq
                    df_chg_train = self.df_chg[st:ed]
                    
                    # expected returns per target term
                    if isinstance(self.r_e, pd.core.frame.DataFrame):
                        r_e = self.r_e.iloc[st:ed].values.mean()
                    else:
                        r_e = self.r_e
                    
                    # x_p: min variance portfolio
                    x_p = self.calc_portfolio(df_chg_train, r_e)
                    
                    # df_chg_test
                    st = idx - self.rebalance_freq
                    ed = idx
                    df_chg_test = self.df_chg[st:ed]
                    df_chgcum_test = (1.0 + df_chg_test).cumprod() - 1.0
                                                            
                    # ror_p: rate of return (portfolio)
                    ror_test = df_chgcum_test.iloc[-1].values
                    ror_p = float(np.dot(ror_test, x_p))
                    df_bt_r.loc[date] = ror_test
                    df_bt_x.loc[date] = x_p
                    
                    # std (portfolio)
                    if self.rebalance_freq == 1:
                        std_p = np.nan
                    else:
                        std_test = df_chg_test.std(ddof=True).values
                        std_p = float(np.dot(std_test, np.abs(x_p)))

                    # append
                    df_one = pd.DataFrame([[ror_p, std_p]], index=[date], columns=df_bt.columns)                    
                    df_bt = df_bt.append(df_one)
                    
        # reset index
        self.df_bt = self._reset_index(df_bt)
        self.df_bt_r = self._reset_index(df_bt_r)  
        self.df_bt_x = self._reset_index(df_bt_x)  
        return self.df_bt

    def calc_portfolio(self, df_retchg, r_e):
        r = df_retchg.mean().values
        cov = np.array(df_retchg.cov())
        x_opt = self.cvxopt_qp_solver(r, r_e, cov)
        return x_opt
        
    def cvxopt_qp_solver(self, r, r_e, cov):
        &amp;quot;&amp;quot;&amp;quot;
        CVXOPT QP Solver for Markowitz&#39; Mean-Variance Model
        - See also https://cvxopt.org/userguide/coneprog.html#quadratic-programming
        - See also https://cdn.hackaday.io/files/277521187341568/art-mpt.pdf
        
        r: mean returns of target assets. (vector)
        r_e: min of the return ratio (= capital gain / investment).
        cov: covariance matrix of target assets. (matrix)
        &amp;quot;&amp;quot;&amp;quot;
        n = len(r)
        r = cvxopt.matrix(r)

        # Create Objective matrices
        P = cvxopt.matrix(2.0 * np.array(cov))
        q = cvxopt.matrix(np.zeros((n, 1)))

        # Create constraint matrices
        G = cvxopt.matrix(np.concatenate((-np.transpose(r), -np.eye(n)), 0))
        h = cvxopt.matrix(np.concatenate((-np.ones((1,1))*r_e, np.zeros((n,1))), 0))
        A = cvxopt.matrix(1.0, (1, n))
        b = cvxopt.matrix(1.0)
        
        # Adjust params (stop log messages)
        cvxopt.solvers.options[&#39;show_progress&#39;] = False # default: True
        cvxopt.solvers.options[&#39;maxiters&#39;] = 1000 # default: 100
        
        sol = cvxopt.solvers.qp(P, q, G, h, A, b)
        x_opt = np.squeeze(np.array(sol[&#39;x&#39;]))
        return x_opt
    
    def get_yearly_performance(self):
        if self.df_bt is None:
            pass
        else:
            df_yearly = self.df_bt[[&amp;quot;ror&amp;quot;]].resample(&#39;y&#39;).sum()
            df_yearly[&amp;quot;std&amp;quot;] = self.df_bt[&amp;quot;ror&amp;quot;].resample(&#39;y&#39;).std().values
            df_yearly[&amp;quot;sharpe_ratio&amp;quot;] = df_yearly.apply(lambda d: (d[&amp;quot;ror&amp;quot;] - self.r_f) / d[&amp;quot;std&amp;quot;], axis=1)
            return df_yearly

    def evaluate_backtest(self, logging=False):   
        if self.df_bt is None:
            pass
        else:
            self.r_mean = self.df_bt[&amp;quot;ror&amp;quot;].mean()
            self.r_std = self.df_bt[&amp;quot;ror&amp;quot;].std(ddof=True)
            self.sharpe_ratio = (self.r_mean - self.r_f) / self.r_std
            self.net_capgain = (self.df_bt[&amp;quot;ror&amp;quot;] + 1.0).cumprod().iloc[-1] - 1.0
            
            self.r_mean_peryear = 12 * self.r_mean
            self.r_std_peryear = np.sqrt(12) * self.r_std
            self.sharpe_ratio_peryear = (self.r_mean_peryear - self.jgb_int) / self.r_std_peryear

            if logging:
                print(&amp;quot;Portfolio Performance&amp;quot;)
                print(&amp;quot;=======================&amp;quot;)
                print(&amp;quot;Returns per month&amp;quot;)
                print(&amp;quot;  sharpe ratio     : {:.8f}&amp;quot;.format(self.sharpe_ratio))
                print(&amp;quot;  mean of returns  : {:.8f}&amp;quot;.format(self.r_mean))
                print(&amp;quot;  std of returns   : {:.8f}&amp;quot;.format(self.r_std))
                print(&amp;quot;    risk-free rate : {:.8f}&amp;quot;.format(self.r_f))
                print(&amp;quot;    capgain ratio  : {:.8f}&amp;quot;.format(self.net_capgain))
                print(&amp;quot;Returns per year&amp;quot;)
                print(&amp;quot;  sharpe ratio     : {:.8f}&amp;quot;.format(self.sharpe_ratio_peryear))
                print(&amp;quot;  mean of returns  : {:.8f}&amp;quot;.format(self.r_mean_peryear))
                print(&amp;quot;  std of returns   : {:.8f}&amp;quot;.format(self.r_std_peryear))
                
            
    def plot_returns(self):
        if self.df_bt is None:
            pass
        else:
            xlabels = [d.strftime(&#39;%Y-%m&#39;) for idx, d in enumerate(self.df_bt.index) if idx % 12 == 0]
            
            fig, ax = plt.subplots(figsize=(12,6))
            ax.plot(self.df_bt.index.values, self.df_bt[&amp;quot;ror&amp;quot;].values, label=&amp;quot;rate of returns&amp;quot;)
            ax.plot(self.df_bt.index.values, self.df_bt[&amp;quot;ror&amp;quot;].cumsum().values, label=&amp;quot;total capital gain ratio&amp;quot;)
            ax.legend(loc=&amp;quot;upper left&amp;quot;)
            ax.set_xticks(xlabels)
            ax.set_xticklabels(xlabels, rotation=40)
            return fig            
        
    def plot_returns_histgram(self):
        if self.df_bt is None:
            pass
        else:
            x = self.df_bt[&amp;quot;ror&amp;quot;].values
            r_mean = &amp;quot;{:.4f}&amp;quot;.format(x.mean())
            r_std = &amp;quot;{:.4f}&amp;quot;.format(x.std())
            
            fig, ax = plt.subplots(figsize=(12,6))
            ax.hist(x, bins=30, alpha=0.75)
            ax.set_title(f&amp;quot;mean={r_mean}, std={r_std}&amp;quot;)
            return fig
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-使い方&#34;&gt;4.2. 使い方&lt;/h3&gt;
&lt;p&gt;対象資産としてTOPIX Core30に含まれる内国株30銘柄を選び，これらに(最適な)投資比率を与えてバックテストしてみましょう．&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/295228/f10c6efd-6301-ee1a-8a68-2e7e495f9bc5.png&#34; alt=&#34;topixcore30_chg_20041031-20201031.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/295228/c0361f2e-ff37-7ed8-b06c-05a4602ac4f0.png&#34; alt=&#34;topixcore30_cum_20041031-20201031.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;まず，&lt;code&gt;pandas_datareader.data.DataReader&lt;/code&gt;でTOPIX Core30構成銘柄のヒストリカルデータを読み込んで，すこし整形します．&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Get historical data
st = &#39;2004/10/31&#39; # start date
ed = &#39;2020/10/31&#39; # end date
stocks_topix30 = [2914, 3382, 4063, 4452, 4502, 
                  4503, 5401, 6301, 6501, 6502, 
                  6752, 6758, 6954, 7201, 7203, 
                  7267, 7751, 8031, 8058, 8306, 
                  8316, 8411, 8604, 8766, 8802, 
                  9021, 9432, 9433, 9437, 9984] # list of tickers in TOPIX Core30
symbols =  [str(s)+&#39;.T&#39; for s in stocks_topix30] 
dfs = []
for symbol in symbols:
    df = pandas_datareader.data.DataReader(symbol, &#39;yahoo&#39;, st, ed) # daily
    df = df.resample(&#39;M&#39;).mean() # daily -&amp;gt; monthly
    df = df.sort_values(by=&#39;Date&#39;, ascending=True)
    df = df.fillna(method=&#39;ffill&#39;) # 1つ前の行の値で埋める
    df = df[[&#39;Close&#39;]].rename(columns={&#39;Close&#39;: symbol})
    dfs.append(df)
df_tpx30 = pd.concat(dfs, axis=1)

# fill nan
for col in df_tpx30.columns:
    st_idx = df_tpx30[col].first_valid_index()
    ed_idx = df_tpx30[col].last_valid_index()
    # for any columns (stocks)
    if df_tpx30[col].isnull().any():
        # New listing (新規上場)
        if st_idx != df_tpx30.index[0]:
            df_tpx30[col] = df_tpx30[col].fillna(df_tpx30[col][st_idx])
        # Delisting (上場廃止)
        if df_tpx30.index[-1] != ed_idx:
            df_tpx30[col] = df_tpx30[col].fillna(df_tpx30[col][ed_idx])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんな感じのパネルデータができれば準備OK．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df_tpx30.tail()

Date	    2914.T	    3382.T	    4063.T	    4452.T	    4502.T	    4503.T	    5401.T	    6301.T	    6501.T	    6502.T	...	8316.T	    8411.T	    8604.T	    8766.T	8802.T	    9021.T	9432.T	    9433.T	    9437.T	    9984.T																				
2020-06-30	2147.159091	3710.272727	12471.136364	8774.045455	4024.818182	1824.386364	1063.240909	2220.500000	3561.590909	3275.681818	...	3172.181818	1363.545455	486.763636	4795.681818	1701.840909	6502.181818	2500.454545	3184.863636	2913.454545	5287.318182
2020-07-31	1933.785714	3427.333333	12802.619048	8465.428571	3763.000000	1731.785714	998.023810	2239.047619	3371.714286	3450.714286	...	3029.809524	1347.857143	491.138096	4699.238095	1576.000000	5405.428571	2523.428571	3289.142857	2944.547619	6311.333333
2020-08-31	1995.300000	3399.050000	12785.500000	8041.000000	3967.150000	1712.075000	1009.300000	2207.650000	3489.050000	3351.750000	...	3023.050000	1402.250000	531.764998	4779.850000	1644.575000	5106.050000	2570.875000	3285.300000	3066.400000	6453.700000
2020-09-30	1970.425000	3357.000000	13804.250000	8053.550000	3898.200000	1622.550000	1073.164999	2352.600000	3631.650000	2941.300000	...	3090.425000	1402.175000	522.770003	4871.900000	1638.575000	5578.100000	2313.800000	2851.150000	2879.875000	6278.600000
2020-10-31	1989.095238	3412.714286	14189.761905	7731.619048	3568.904762	1489.047619	1070.538095	2432.285714	3605.000000	2783.952381	...	2969.428571	1311.571429	487.642857	4804.000000	1611.214286	4938.571429	2237.142857	2742.738095	3882.095238	6991.047619
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あとは，自作クラス&lt;code&gt;MarkowitzMinVarianceModel()&lt;/code&gt;のインスタンスオブジェクト&lt;code&gt;model&lt;/code&gt;にパラメータと価格データ&lt;code&gt;df_tpx30&lt;/code&gt;を食わせてバックテストを実行．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime

# Const.
ST_BACKTEST = datetime(2011,10,31) # Investment period (start date)
ED_BACKTEST = datetime(2020,10,31) # Investment period (end date)

# Params
params = {
    &amp;quot;window_size&amp;quot;: 36, # 収益率の特性量(平均，分散)の推定に使う期間 (例: 運用時から過去36カ月)
    &amp;quot;rebalance_freq&amp;quot;: 1, # リバランスの頻度 (1か月ごとにポートフォリオ内の投資比率を変更)
    &amp;quot;r_f&amp;quot;: 0.0001 * (1/12) # リスクフリーレート (日本国債10年物利回り:0.01%を単利計算で月次に変換)
}

# Data
st = (ST_BACKTEST - relativedelta(months=params[&amp;quot;window_size&amp;quot;])).strftime(&#39;%Y-%m-%d&#39;)
ed = ED_BACKTEST.strftime(&#39;%Y-%m-%d&#39;)
df = df_tpx30[st:ed]
params[&amp;quot;r_e&amp;quot;]=  df_tpx[st:ed] # 要求期待収益率(r_e)は同時期のTOPIX Indexの収益率とする (df_tpx作成コードは省略)

# Create model
model = MarkowitzMinVarianceModel(df, **params)

# Backtest by model
df_bt = model.backtest()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここからは，自作クラス&lt;code&gt;MarkowitzMinVarianceModel()&lt;/code&gt;に用意したバックテスト評価用のメソッドを使う．(分析は無限大)&lt;/p&gt;
&lt;h5 id=&#34;ポートフォリオのパフォーマンス評価&#34;&gt;ポートフォリオのパフォーマンス評価&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Evaluate
model.evaluate_backtest(logging=True)

Portfolio Performance
=======================
Returns per month
  sharpe ratio     : 0.18788996
  mean of returns  : 0.00735206
  std of returns   : 0.03908527
    risk-free rate : 0.00000833
    capgain ratio  : 1.04714952
Returns per year
  sharpe ratio     : 0.65086993
  mean of returns  : 0.08822476
  std of returns   : 0.13539535
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;ポートフォリオの収益率累積収益率プロット&#34;&gt;ポートフォリオの収益率・累積収益率プロット&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = model.plot_returns() # Plot returns
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/295228/360b0fc7-2d30-ad33-958e-44bc412026dd.png&#34; alt=&#34;mmvp_tpx30_w=36_plot.png&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;ポートフォリオの月次収益率分布&#34;&gt;ポートフォリオの月次収益率分布&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = model.plot_returns_histgram()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/295228/608c7327-1312-35d7-0c13-5464a98ade5f.png&#34; alt=&#34;mmvp_tpx30_w=36_hist.png&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;ポートフォリオの年次パフォーマンス&#34;&gt;ポートフォリオの年次パフォーマンス&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_yearly = model.get_yearly_performance()
df_yearly

date		ror	    std    	    sharpe_ratio
2011-12-31	-0.0001	3.3888e-05	-3.6736
2012-12-31	-0.0444	1.2435e-02	-3.5695
2013-12-31	0.5524	6.5010e-02	8.4973
2014-12-31	0.2448	5.2800e-02	4.6357
2015-12-31	0.0952	4.1543e-02	2.2923
2016-12-31	-0.0970	4.0639e-02	-2.3871
2017-12-31	0.2486	3.0262e-02	8.2144
2018-12-31	-0.0097	3.6705e-02	-0.2644
2019-12-31	0.0254	3.1904e-02	0.7947
2020-12-31	-0.1793	7.3461e-02	-2.4404
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;ポートフォリオ内の各銘柄の収益率&#34;&gt;ポートフォリオ内の各銘柄の収益率(%)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_bt_r = model.get_dfbt_r() # rate_of_returns
df_bt_x = model.get_dfbt_x() # investment_ratio

df1 = df_bt_r * df_bt_x # (rate_of_returns) × (investment_ratio)

df1 = df1.resample(&amp;quot;y&amp;quot;).sum()
df1.columns = [c.replace(&amp;quot;.T&amp;quot;, &amp;quot;&amp;quot;) for c in df1.columns]
df1 = df1.T * 100 # transpose &amp;amp;&amp;amp; convert as pct.
df1.columns = [c.strftime(&#39;%Y&#39;) for c in df1.columns]

plt.figure(figsize=(12,12))
sns.heatmap(df1, cmap=&amp;quot;RdBu&amp;quot;, center=0, annot=True, fmt=&amp;quot;.2f&amp;quot;, cbar=True)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/295228/64fac1bb-3bcc-c673-fbf7-b8ef77482995.png&#34; alt=&#34;mmvp_tpx30_w=36_hm.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;最後まで読んでいただき，ありがとうございます！&lt;/p&gt;
&lt;div class=&#39;pixels-photo&#39;&gt;
&lt;a href=&#39;https://500px.com/photo/284676583/thanks-by-Esther-Moreno&#39; alt=&#39;thanks by Esther Moreno on 500px.com&#39;&gt;
  &lt;img src=&#39;https://drscdn.500px.org/photo/284676583/m%3D900/v2?sig=2c8aeb84d84531b9e9050dab1d209ed269be3747408c2f74e172ac60e7c89f52&#39; alt=&#39;thanks by Esther Moreno on 500px.com&#39; /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&#39;text/javascript&#39; src=&#39;https://500px.com/embed.js&#39;&gt;&lt;/script&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;code&gt;stocks_topix30&lt;/code&gt;はTOPIX Core30構成銘柄の証券コードのリストです．構成銘柄は毎年10/31に更新されます．サンプルコードを再現したい場合&lt;code&gt;stocks_topix30 = [2914, 3382, 4063, 4452, 4502, 4503, 5401, 6301, 6501, 6502, 6752, 6758, 6954, 7201, 7203, 7267, 7751, 8031, 8058, 8306, 8316, 8411, 8604, 8766, 8802, 9021, 9432, 9433, 9437, 9984]&lt;/code&gt;としてください． &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Counterfactual Regret Minimization</title>
      <link>https://yumaloop.github.io/post/2020-02-10-counterfactual-regret-minimization/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://yumaloop.github.io/post/2020-02-10-counterfactual-regret-minimization/</guid>
      <description>&lt;p&gt;In this post, I introduce you the Counterfactual Regret Minimization (CFR Algorithm). It is mainly used for the algorithm to figure out the optimal strategy of a extensive-form game with incomplete information such as Poker and Mahjong.&lt;/p&gt;
&lt;h3 id=&#34;extensive-form-game&#34;&gt;Extensive-form Game&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Set, variables
&lt;ul&gt;
&lt;li&gt;$N: $ set of players
&lt;ul&gt;
&lt;li&gt;$i \in N$: player&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$A :$ set of actions
&lt;ul&gt;
&lt;li&gt;$a \in A: $ action&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$H: $set of sequences
&lt;ul&gt;
&lt;li&gt;$h \in H: $ sequences (= possible history of actions, $h = (a_1, \dots, a_t$)&lt;/li&gt;
&lt;li&gt;$Z \subseteq H: $ set of terminal histories. $Z = {z \in H \vert \forall h \in H, z \notin h }$&lt;/li&gt;
&lt;li&gt;$z \in Z$: sea&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Function, relations
&lt;ul&gt;
&lt;li&gt;$u_i: Z \to \mathbb{R}: $ utility function of player $i$&lt;/li&gt;
&lt;li&gt;$\sigma_i: A \to [0,1]$ a strategy of player $i$, probability distribution on action set $A$.&lt;/li&gt;
&lt;li&gt;$\sigma~: A^N \to [0,1]$ a strategy profile, $\sigma := (\sigma_1, \dots, \sigma_N)$&lt;/li&gt;
&lt;li&gt;$\pi^{\sigma}&lt;em&gt;i: H \to [0,1]: $ probability of history $h$ under a strategy $$\sigma&lt;/em&gt;$ of player $i$&lt;/li&gt;
&lt;li&gt;$\pi^{\sigma}: H^N \to [0,1]: $ probability of history $h$ under a strategy profile $\sigma$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then, you can also interplate $u_i$ as the function mapping a storategy profile $\sigma$ to its utility.&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
u_i(\sigma)
&amp;amp;= \sum_{h \in Z} u_i(h) \pi^{\sigma}(h) \\&lt;br&gt;
&amp;amp;= \sum_{h \in Z} u_i(h) \prod_{i \in N} \pi^{\sigma}_i(h)
\end{align}
$$
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;nash-equilibrium&#34;&gt;Nash equilibrium&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; $(\text{Nash equilibrium})$&lt;/p&gt;
&lt;p&gt;In $N$-player extensive game, a strategy profile $\acute{\sigma} := (\acute{\sigma_1}, \dots, \acute{\sigma_N})$ is the Nash equilibrium if and only if the followings holds.&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
u_1(\acute{\sigma_1}, \dots, \acute{\sigma_N})
&amp;amp;\geq \underset{\sigma_1}{\rm max} ~ u_1(\sigma_1, \acute{\sigma_{-1}}) \\&lt;br&gt;
u_2(\acute{\sigma_1}, \dots, \acute{\sigma_N})
&amp;amp;\geq \underset{\sigma_2}{\rm max} ~ u_2(\sigma_2, \acute{\sigma_{-2}}) \\&lt;br&gt;
&amp;amp;~ \vdots \\&lt;br&gt;
u_N(\acute{\sigma_1}, \dots, \acute{\sigma_N})
&amp;amp;\geq \underset{\sigma_N}{\rm max} ~ u_N(\sigma_N, \acute{\sigma_{-N}})
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition: $\text{(}\varepsilon\text{-Nash equilibrium)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In $N$-player extensive game, a strategy profile $\acute{\sigma} := (\acute{\sigma_1}, \dots, \acute{\sigma_N})$ is the $\varepsilon$-Nash equilibrium if and only if the followings holds when $\forall \varepsilon \geq 0$ is given.&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
u_1(\acute{\sigma_1}, \dots, \acute{\sigma_N}) + \varepsilon
&amp;amp;\geq \underset{\sigma_1}{\rm max} ~ u_1(\sigma_1, \acute{\sigma_{-1}}) \\&lt;br&gt;
u_2(\acute{\sigma_1}, \dots, \acute{\sigma_N}) + \varepsilon
&amp;amp;\geq \underset{\sigma_2}{\rm max} ~ u_2(\sigma_2, \acute{\sigma_{-2}}) \\&lt;br&gt;
&amp;amp;~ \vdots \\&lt;br&gt;
u_N(\acute{\sigma_1}, \dots, \acute{\sigma_N}) + \varepsilon
&amp;amp;\geq \underset{\sigma_N}{\rm max} ~ u_N(\sigma_N, \acute{\sigma_{-N}})
\end{aligned}
$$&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;regret-matching&#34;&gt;Regret matching&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Average overall regret of player $i$ at time $T$：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
R_i^T
:= \underset{\sigma_i^*}{\rm max} ~
\frac{1}{T} \sum_{t=1}^{T} \left( u_i(\sigma_i^*, \sigma_{-i}^{t}) - u_i(\sigma_i^t, \sigma_{-i}^{t}) \right)
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Average strategy for player $i$ from time $1$ to $T$：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{align}
\overline{\sigma}_i^t(I)(a)
&amp;amp;:= \frac{\sum_{t=1}^{T} \pi_i^{\sigma^t}(I) \cdot \sigma^t(I)(a)}{\sum_{t=1}^{T} \pi_i^{\sigma^t}(I)} \\&lt;br&gt;
&amp;amp;= \frac{\sum_{t=1}^{T} \sum_{h \in I} \pi_i^{\sigma^t}(h) \cdot \sigma^t(h)(a)}{\sum_{t=1}^{T} \sum_{h \in I} \pi_i^{\sigma^t}(h)}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;If the average overall regret holds $R_i^T \leq \varepsilon$, the average strategy $\overline{\sigma}_i^t(I)(a) $ is $2 \varepsilon$-Nash equilibrium for player $i$ in time $t$. So that, in order to derive Nash equilibrium, we should minimize the average overall regret $R_i^T$ or its upper bound $\varepsilon$ according to $R_i^T \to 0 ~~ (\varepsilon \to 0)$.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;cfr-algorithm&#34;&gt;CFR Algorithm&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Counterfactual utility：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{align}
u_i(\sigma, I) = \frac{\sum_{h \in H, h&#39; \in Z} \pi_{-i}^{\sigma}(h)\pi^{\sigma}(h,h&#39;)u_i(h) }{\pi_{-i}^{\sigma}(I)}
\end{align}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;immediate counteractual regret of action $a$ in Information set $I$:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{aligned}
R_{i,imm}^{T}(I, a)
:=
\frac{1}{T} \sum_{t=1}^{T}
\pi_{-i}^{\sigma^t}(I)
\left(
u_i(\sigma^t_{I \to a}, I) - u_i(\sigma^t, I)
\right)
\end{aligned}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immediate counterfactual regret of Information set $I$：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{aligned}
R_{i,imm}^{T}(I)
&amp;amp;:= \underset{a \in A(I)}{\rm max} ~
\frac{1}{T} \sum_{t=1}^{T}
\pi_{-i}^{\sigma^t}(I)
\left(
u_i(\sigma^t_{I \to a}, I) - u_i(\sigma^t, I)
\right)
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;The following inequality holds for &lt;strong&gt;the average overall regret&lt;/strong&gt; $R_i^T $ and &lt;strong&gt;the immediate counterfactual regret&lt;/strong&gt;  $R_{i,imm}^{T}(I)$:&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
R_i^T
\leq \sum_{I \in \mathcal{I}_i} &amp;amp;R_{i,imm}^{T,+}(I) \\&lt;br&gt;
where ~~~
&amp;amp;R_{i,imm}^{T, +}(I)
:= max(R_{i,imm}^{T}(I), 0)
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;So that, we obtain the sufficient condition of $R_{i,imm}^{T}(I)$  for the average strategy $\overline{\sigma}_i^t(I)(a)$ to become a Nash equilibrium strategy as below.&lt;/p&gt;
&lt;p&gt;$$
\sum_{I \in \mathcal{I}_i} R_{i,imm}^{T,+}(I) \to 0 ~~~ \Rightarrow ~~~ R_i^T \to 0 ~~~ \Rightarrow ~~~ \varepsilon \to 0.
$$&lt;/p&gt;
&lt;p&gt;Now all we need is to minimize the immediate counterfactual regret  $R_{i,imm}^{T}(I)$.&lt;/p&gt;
&lt;p&gt;In addition, as can be seen from the above formula, the computational complexity of the CFR algorithm depends on the number of information sets $I$. Also, to avoid the complete search of game tree (searching all information sets $I$), subsequent algorithms such as CFR + propose an abstraction of the game state.&lt;/p&gt;
&lt;h3 id=&#34;python-code-to-run-cfr-algorithm-for-kuhn-poker&#34;&gt;Python code to run CFR algorithm for Kuhn Poker&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

# Number of actions a player can take at a decision node.
_N_ACTIONS = 2
_N_CARDS = 3

def main():
    &amp;quot;&amp;quot;&amp;quot;
    Run iterations of counterfactual regret minimization algorithm.
    &amp;quot;&amp;quot;&amp;quot;
    i_map = {}  # map of information sets
    n_iterations = 10000
    expected_game_value = 0

    for _ in range(n_iterations):
        expected_game_value += cfr(i_map)
        for _, v in i_map.items():
            v.next_strategy()

    expected_game_value /= n_iterations
    display_results(expected_game_value, i_map)


def cfr(i_map, history=&amp;quot;&amp;quot;, card_1=-1, card_2=-1, pr_1=1, pr_2=1, pr_c=1):
    &amp;quot;&amp;quot;&amp;quot;
    Counterfactual regret minimization algorithm.
    Parameters
    ----------
    i_map: dict
        Dictionary of all information sets.
    history : [{&#39;r&#39;, &#39;c&#39;, &#39;b&#39;}], str
        A string representation of the game tree path we have taken.
        Each character of the string represents a single action:
        &#39;r&#39;: random chance action
        &#39;c&#39;: check action
        &#39;b&#39;: bet action
    card_1 : (0, 2), int
        player A&#39;s card
    card_2 : (0, 2), int
        player B&#39;s card
    pr_1 : (0, 1.0), float
        The probability that player A reaches `history`.
    pr_2 : (0, 1.0), float
        The probability that player B reaches `history`.
    pr_c: (0, 1.0), float
        The probability contribution of chance events to reach `history`.
    &amp;quot;&amp;quot;&amp;quot;
    if is_chance_node(history):
        return chance_util(i_map)
    if is_terminal(history):
        return terminal_util(history, card_1, card_2)

    n = len(history)
    is_player_1 = n % 2 == 0
    info_set = get_info_set(i_map, card_1 if is_player_1 else card_2, history)

    strategy = info_set.strategy
    if is_player_1:
        info_set.reach_pr += pr_1
    else:
        info_set.reach_pr += pr_2

    # Counterfactual utility per action.
    action_utils = np.zeros(_N_ACTIONS)

    for i, action in enumerate([&amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;]):
        next_history = history + action
        if is_player_1:
            action_utils[i] = -1 * cfr(i_map, next_history, card_1, card_2, pr_1 * strategy[i], pr_2, pr_c)
        else:
            action_utils[i] = -1 * cfr(i_map, next_history, card_1, card_2, pr_1, pr_2 * strategy[i], pr_c)

    # Utility of information set.
    util = sum(action_utils * strategy)
    regrets = action_utils - util
    if is_player_1:
        info_set.regret_sum += pr_2 * pr_c * regrets
    else:
        info_set.regret_sum += pr_1 * pr_c * regrets

    return util

def is_chance_node(history):
    &amp;quot;&amp;quot;&amp;quot;
    Determine if we are at a chance node based on tree history.
    &amp;quot;&amp;quot;&amp;quot;
    return history == &amp;quot;&amp;quot;

def chance_util(i_map):
    expected_value = 0
    n_possibilities = 6
    for i in range(_N_CARDS):
        for j in range(_N_CARDS):
            if i != j:
                expected_value += cfr(i_map, &amp;quot;rr&amp;quot;, i, j, 1, 1, 1/n_possibilities)
    return expected_value/n_possibilities


def is_terminal(history):
    possibilities = { &amp;quot;rrcc&amp;quot;: True, &amp;quot;rrcbc&amp;quot;: True,
                     &amp;quot;rrcbb&amp;quot;: True, &amp;quot;rrbc&amp;quot;: True, &amp;quot;rrbb&amp;quot;: True}
    return history in possibilities

def terminal_util(history, card_1, card_2):
    n = len(history)
    card_player = card_1 if n % 2 == 0 else card_2
    card_opponent = card_2 if n % 2 == 0 else card_1

    if history == &amp;quot;rrcbc&amp;quot; or history == &amp;quot;rrbc&amp;quot;:
        # Last player folded. The current player wins.
        return 1
    elif history == &amp;quot;rrcc&amp;quot;:
        # Showdown with no bets
        return 1 if card_player &amp;gt; card_opponent else -1

    # Showdown with 1 bet
    assert(history == &amp;quot;rrcbb&amp;quot; or history == &amp;quot;rrbb&amp;quot;)
    return 2 if card_player &amp;gt; card_opponent else -2

def card_str(card):
    if card == 0:
        return &amp;quot;J&amp;quot;
    elif card == 1:
        return &amp;quot;Q&amp;quot;
    elif card == 2:
        return &amp;quot;K&amp;quot;

def get_info_set(i_map, card, history):
    &amp;quot;&amp;quot;&amp;quot;
    Retrieve information set from dictionary.
    &amp;quot;&amp;quot;&amp;quot;
    key = card_str(card) + &amp;quot; &amp;quot; + history
    info_set = None

    if key not in i_map:
        info_set = InformationSet(key)
        i_map[key] = info_set
        return info_set

    return i_map[key]

class InformationSet():
    def __init__(self, key):
        self.key = key
        self.regret_sum = np.zeros(_N_ACTIONS)
        self.strategy_sum = np.zeros(_N_ACTIONS)
        self.strategy = np.repeat(1/_N_ACTIONS, _N_ACTIONS)
        self.reach_pr = 0
        self.reach_pr_sum = 0
        
    def next_strategy(self):
        self.strategy_sum += self.reach_pr * self.strategy
        self.strategy = self.calc_strategy()
        self.reach_pr_sum += self.reach_pr
        self.reach_pr = 0

    def calc_strategy(self):
        &amp;quot;&amp;quot;&amp;quot;
        Calculate current strategy from the sum of regret.
        &amp;quot;&amp;quot;&amp;quot;
        strategy = self.make_positive(self.regret_sum)
        total = sum(strategy)
        if total &amp;gt; 0:
            strategy = strategy / total
        else:
            n = _N_ACTIONS
            strategy = np.repeat(1/n, n)

        return strategy

    def get_average_strategy(self):
        &amp;quot;&amp;quot;&amp;quot;
        Calculate average strategy over all iterations. This is the
        Nash equilibrium strategy.
        &amp;quot;&amp;quot;&amp;quot;
        strategy = self.strategy_sum / self.reach_pr_sum

        # Purify to remove actions that are likely a mistake
        strategy = np.where(strategy &amp;lt; 0.001, 0, strategy)

        # Re-normalize
        total = sum(strategy)
        strategy /= total

        return strategy

    def make_positive(self, x):
        return np.where(x &amp;gt; 0, x, 0)

    def __str__(self):
        strategies = [&#39;{:03.2f}&#39;.format(x)
                      for x in self.get_average_strategy()]
        return &#39;{} {}&#39;.format(self.key.ljust(6), strategies)

def display_results(ev, i_map):
    print(&#39;player 1 expected value: {}&#39;.format(ev))
    print(&#39;player 2 expected value: {}&#39;.format(-1 * ev))

    print()
    print(&#39;player 1 strategies:&#39;)
    sorted_items = sorted(i_map.items(), key=lambda x: x[0])
    for _, v in filter(lambda x: len(x[0]) % 2 == 0, sorted_items):
        print(v)
    print()
    print(&#39;player 2 strategies:&#39;)
    for _, v in filter(lambda x: len(x[0]) % 2 == 1, sorted_items):
        print(v)

if __name__ == &amp;quot;__main__&amp;quot;:
    main()

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Automatically Login to keio.jp using Selenium on Python</title>
      <link>https://yumaloop.github.io/post/2019-06-21-keiojp-auto-login/</link>
      <pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://yumaloop.github.io/post/2019-06-21-keiojp-auto-login/</guid>
      <description>&lt;p&gt;Have you ever want to login to keio.jp automatically? Don&amp;rsquo;t you think it is cool? At least I think so and I write down the way to achieve that with Python.&lt;/p&gt;
&lt;br&gt;
&lt;div style=&#34;text-align:center&#34;&gt;
  &lt;video style=&#34;width: 100%;&#34; controls autoplay loop muted&gt;
    &lt;source src=&#34;{{ &#34;/assets/video/keio_login.mp4&#34; | relative_url }}&#34; type=&#34;video/mp4&#34;&gt;
    &lt;p&gt;Your browser does not support the video tag.&lt;/p&gt;
  &lt;/video&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;p&gt;In order to login to keio.jp (Keio Single Sign-On System), it is necessary to satisfy the page transition as below.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://auth.keio.jp&#34;&gt;https://auth.keio.jp&lt;/a&gt; (SSO login page)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gslbs.adst.keio.ac.jp/student/index.html&#34;&gt;https://gslbs.adst.keio.ac.jp/student/index.html&lt;/a&gt; (Syllabus page)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.edu.keio.jp/ess2/login?&#34;&gt;https://www.edu.keio.jp/ess2/login?&lt;/a&gt; (Class support page)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, this time, a static web-scraping library like BeautifulSoup is not enough, because it doesn&amp;rsquo;t support the dynamic site with Javascript or page redirection. Then I use &lt;a href=&#34;https://selenium.dev/documentation/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Selenium&lt;/a&gt; and &lt;a href=&#34;http://chromedriver.chromium.org/getting-started&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ChromeDriver&lt;/a&gt; in python.&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;example-1--auto-login-to-keiojp&#34;&gt;Example 1 : Auto login to keio.jp&lt;/h4&gt;
&lt;p&gt;If you are the student in Keio University, you can login to keio.jp automatically. All you need is to assign your email address and password in the below script and run it in command line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException

ID = &amp;quot;*****&amp;quot; # your email in keio.jp (ex. example@keio.jp)  #
PW = &amp;quot;*****&amp;quot; # your password in keio.jp #

# Optional settings of chrome driver
options = webdriver.ChromeOptions()
options.add_argument(&#39;--headless&#39;)

# Boot chrome driver
driver = webdriver.Chrome(&amp;quot;/usr/local/bin/chromedriver&amp;quot;, options=options)
driver.set_page_load_timeout(15) # Time out 15 sec

# GET (HTML Page)
driver.get(&amp;quot;https://auth.keio.jp&amp;quot;)

# Find elements and POST (send keys to the input tag)
id_element = driver.find_element_by_name(&amp;quot;j_username&amp;quot;)
id_element.send_keys(ID)
pw_element = driver.find_element_by_name(&amp;quot;j_password&amp;quot;)
pw_element.send_keys(PW)

# Click login button
login_button = driver.find_element_by_name(&amp;quot;_eventId_proceed&amp;quot;)
login_button.click()

# GET (HTML Page)
driver.get(&amp;quot;https://gslbs.adst.keio.ac.jp/student/index.html&amp;quot;)

# GET (HTML Page)
driver.get(&amp;quot;https://www.edu.keio.jp/ess2/login?&amp;quot;)

# Close chrome driver
driver.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;example-2--auto-login-to-twittercom&#34;&gt;Example 2 : Auto login to twitter.com&lt;/h4&gt;
&lt;p&gt;If you have twitter account, you can also login to twitter.com automatically. All you need is to assign your username (@********) and password (********) in the below script and run it in command line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException

USERNAME=&amp;quot;*****&amp;quot; # your username in twitter #
PASSWORD=&amp;quot;*****&amp;quot; # your password in twitter #

# Optional settings of chrome driver
options = webdriver.ChromeOptions()
options.add_argument(&#39;--headless&#39;)

# Boot chrome driver
driver = webdriver.Chrome(&amp;quot;/usr/local/bin/chromedriver&amp;quot;, options=options)
driver.set_page_load_timeout(15) # Time out 15 sec

# GET (HTML Page)
driver.get(&amp;quot;https://twitter.com/login&amp;quot;)

# Find elements and POST (send keys to the input tag)
username_element = driver.find_element_by_class_name(&#39;js-username-field&#39;)
username_element.send_keys(USERNAME)
password_element = driver.find_element_by_class_name(&#39;js-password-field&#39;)
password_element.send_keys(PASSWORD)

# Click login button
login_button = driver.find_element_by_css_selector(&#39;button.submit.EdgeButton.EdgeButton--primary.EdgeButtom--medium&#39;)
login_button.click()

# Close chrome driver
driver.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;example-3--auto-search-in-googlecom&#34;&gt;Example 3 : Auto search in google.com&lt;/h4&gt;
&lt;p&gt;If you refer to Selenium Getting started guide, you can aquire the search result with the keyword &amp;ldquo;cheese&amp;rdquo; at google.com with Selenium on Python. (This requires Selenium WebDriver 3.13 or newer.)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

# Open web driver (Google Chrome)
driver = webdriver.Firefox()

wait = WebDriverWait(driver, 10) 

# GET HTML page source of google.com
driver.get(&amp;quot;https://google.com/ncr&amp;quot;) # GET 
# POST the keyword &amp;quot;cheese&amp;quot; in &amp;quot;q&amp;quot; element in google.com
driver.find_element_by_name(&amp;quot;q&amp;quot;).send_keys(&amp;quot;cheese&amp;quot; + Keys.RETURN) # POST 

first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, &amp;quot;h3&amp;gt;div&amp;quot;)))

# Search result as text
print(first_result.get_attribute(&amp;quot;textContent&amp;quot;))

# Close web driver (Google Chrome)
driver.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The Selenium Browser Automation Project &amp;gt; Getting started &amp;gt; Quick tour&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://selenium.dev/documentation/en/getting_started/quick/#webdriver&#34;&gt;https://selenium.dev/documentation/en/getting_started/quick/#webdriver&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
